[
  {
    "Id": "1051418",
    "ThreadId": "445629",
    "Html": "Is it possible to use downloaded .ttf's with this wrapper? If so, how does one go about importing them?<br />\n",
    "PostedDate": "2013-05-31T16:47:37.363-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1051424",
    "ThreadId": "445629",
    "Html": "They can be used by importing them into DirectWrite and creating text-layouts for them.<br />\nHere's an example.<br />\n<pre><code>// CustomFont.cpp\n\n#include &lt;D3D11.h&gt;\n#include &quot;FW1FontWrapper.h&quot;\n\n#pragma comment (lib, &quot;D3D11.lib&quot;)\n#pragma comment (lib, &quot;FW1FontWrapper.lib&quot;)\n\n// TODO: Custom font settings\n#define CUSTOMFONT_FILEPATH L&quot;../Aegyptus312.otf&quot;\n#define CUSTOMFONT_NAME L&quot;Aegyptus&quot;\n\n#include &lt;string&gt;\n\n// Font enumerator wrapper for a single font\nclass CFontEnum : public IDWriteFontFileEnumerator {\n    public:\n        virtual HRESULT STDMETHODCALLTYPE QueryInterface(REFIID riid, void **ppvObject) {\n            if(ppvObject == NULL)\n                return E_INVALIDARG;\n            \n            if(IsEqualIID(riid, __uuidof(IUnknown))) {\n                *ppvObject = static_cast&lt;IUnknown*&gt;(this);\n                AddRef();\n                return S_OK;\n            }\n            else if(IsEqualIID(riid, __uuidof(IDWriteFontFileEnumerator))) {\n                *ppvObject = static_cast&lt;IDWriteFontFileEnumerator*&gt;(this);\n                AddRef();\n                return S_OK;\n            }\n            \n            *ppvObject = NULL;\n            return E_NOINTERFACE;\n        }\n        \n        virtual ULONG STDMETHODCALLTYPE AddRef() {\n            return static_cast&lt;ULONG&gt;(InterlockedIncrement(reinterpret_cast&lt;LONG*&gt;(&amp;m_cRefCount)));\n        }\n        \n        virtual ULONG STDMETHODCALLTYPE Release() {\n            ULONG newCount = static_cast&lt;ULONG&gt;(InterlockedDecrement(reinterpret_cast&lt;LONG*&gt;(&amp;m_cRefCount)));\n            \n            if(newCount == 0)\n                delete this;\n            \n            return newCount;\n        }\n        \n        virtual HRESULT STDMETHODCALLTYPE GetCurrentFontFile(IDWriteFontFile **ppFontFile) {\n            if(ppFontFile == NULL)\n                return E_INVALIDARG;\n            \n            if(m_pFontFile == NULL)\n                return E_FAIL;\n            \n            m_pFontFile-&gt;AddRef();\n            *ppFontFile = m_pFontFile;\n            \n            return S_OK;\n        }\n        \n        virtual HRESULT STDMETHODCALLTYPE MoveNext(BOOL *pHasCurrentFile) {\n            if(pHasCurrentFile == NULL)\n                return E_INVALIDARG;\n            \n            if(m_count &gt; 0)\n                *pHasCurrentFile = FALSE;\n            else\n                *pHasCurrentFile = TRUE;\n            \n            ++m_count;\n            \n            return S_OK;\n        }\n    \n    public:\n        CFontEnum(IDWriteFontFile *pFontFile) :\n            m_cRefCount(1),\n            m_pFontFile(pFontFile),\n            m_count(0)\n        {\n            if(m_pFontFile)\n                m_pFontFile-&gt;AddRef();\n        }\n    \n    private:\n        ~CFontEnum() {\n            if(m_pFontFile)\n                m_pFontFile-&gt;Release();\n        }\n    \n    private:\n        ULONG                       m_cRefCount;\n        IDWriteFontFile             *m_pFontFile;\n        UINT                        m_count;\n    \n    private:\n        CFontEnum(const CFontEnum&amp;);\n        CFontEnum&amp; operator=(const CFontEnum&amp;);\n};\n\n// Font collection loader for a single font\nclass CCollectionLoader : public IDWriteFontCollectionLoader {\n    public:\n        virtual HRESULT STDMETHODCALLTYPE QueryInterface(REFIID riid, void **ppvObject) {\n            if(ppvObject == NULL)\n                return E_INVALIDARG;\n            \n            if(IsEqualIID(riid, __uuidof(IUnknown))) {\n                *ppvObject = static_cast&lt;IUnknown*&gt;(this);\n                AddRef();\n                return S_OK;\n            }\n            else if(IsEqualIID(riid, __uuidof(IDWriteFontCollectionLoader))) {\n                *ppvObject = static_cast&lt;IDWriteFontCollectionLoader*&gt;(this);\n                AddRef();\n                return S_OK;\n            }\n            \n            *ppvObject = NULL;\n            return E_NOINTERFACE;\n        }\n        \n        virtual ULONG STDMETHODCALLTYPE AddRef() {\n            return static_cast&lt;ULONG&gt;(InterlockedIncrement(reinterpret_cast&lt;LONG*&gt;(&amp;m_cRefCount)));\n        }\n        \n        virtual ULONG STDMETHODCALLTYPE Release() {\n            ULONG newCount = static_cast&lt;ULONG&gt;(InterlockedDecrement(reinterpret_cast&lt;LONG*&gt;(&amp;m_cRefCount)));\n            \n            if(newCount == 0)\n                delete this;\n            \n            return newCount;\n        }\n        \n        virtual HRESULT STDMETHODCALLTYPE CreateEnumeratorFromKey(\n            IDWriteFactory *pFactory,\n            const void *collectionKey,\n            UINT32 collectionKeySize,\n            IDWriteFontFileEnumerator **ppFontFileEnumerator\n        ) {\n            collectionKey;\n            collectionKeySize;\n            \n            if(pFactory == NULL || ppFontFileEnumerator == NULL)\n                return E_INVALIDARG;\n            \n            IDWriteFontFile *pFontFile;\n            HRESULT hResult = pFactory-&gt;CreateFontFileReference(m_filepath.c_str(), NULL, &amp;pFontFile);\n            if(FAILED(hResult))\n                return hResult;\n            \n            CFontEnum *pEnum = new CFontEnum(pFontFile);\n            *ppFontFileEnumerator = pEnum;\n            \n            pFontFile-&gt;Release();\n            \n            return S_OK;\n        }\n    \n    public:\n        CCollectionLoader(const WCHAR *szFontfilePath) :\n            m_cRefCount(1),\n            m_filepath(szFontfilePath)\n        {\n        }\n    \n    private:\n        ~CCollectionLoader() {\n        }\n    \n    private:\n        ULONG                       m_cRefCount;\n        std::wstring                m_filepath;\n    \n    private:\n        CCollectionLoader(const CCollectionLoader&amp;);\n        CCollectionLoader&amp; operator=(const CCollectionLoader&amp;);\n};\n\n\nLRESULT CALLBACK WndProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam);\n\n// Main\nint WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow) {\n    // Register windowclass\n    WNDCLASSEX wc = {0};\n    wc.cbSize = sizeof(wc);\n    wc.lpszClassName = TEXT(&quot;MyClass&quot;);\n    wc.hInstance = hInstance;\n    wc.lpfnWndProc = WndProc;\n    wc.hCursor = LoadCursor(NULL, IDC_ARROW);\n    wc.hIcon = LoadIcon(NULL, IDI_APPLICATION);\n    RegisterClassEx(&amp;wc);\n    \n    // Create window\n    HWND hWnd = CreateWindowEx(\n        WS_EX_OVERLAPPEDWINDOW,\n        wc.lpszClassName,\n        TEXT(&quot;D3D11 Font Wrapper - Custom Font&quot;),\n        WS_OVERLAPPEDWINDOW | WS_CLIPSIBLINGS | WS_CLIPCHILDREN,\n        CW_USEDEFAULT,\n        CW_USEDEFAULT,\n        CW_USEDEFAULT,\n        CW_USEDEFAULT,\n        NULL,\n        NULL,\n        hInstance,\n        NULL\n    );\n    \n    // Create device and swapchain\n    DXGI_SWAP_CHAIN_DESC scd = {0};\n    scd.BufferDesc.Format = DXGI_FORMAT_R8G8B8A8_UNORM;\n    scd.SampleDesc.Count = 1;\n    scd.BufferUsage = DXGI_USAGE_RENDER_TARGET_OUTPUT;\n    scd.BufferCount = 1;\n    scd.OutputWindow = hWnd;\n    scd.SwapEffect = DXGI_SWAP_EFFECT_DISCARD;\n    scd.Windowed = TRUE;\n    \n    IDXGISwapChain *pSwapChain;\n    ID3D11Device *pDevice;\n    ID3D11DeviceContext *pImmediateContext;\n    \n    HRESULT hResult = D3D11CreateDeviceAndSwapChain(\n        NULL,\n        D3D_DRIVER_TYPE_HARDWARE,\n        NULL,\n        0,\n        NULL,\n        0,\n        D3D11_SDK_VERSION,\n        &amp;scd,\n        &amp;pSwapChain,\n        &amp;pDevice,\n        NULL,\n        &amp;pImmediateContext\n    );\n    if(FAILED(hResult)) {\n        MessageBox(NULL, TEXT(&quot;D3D11CreateDeviceAndSwapChain&quot;), TEXT(&quot;Error&quot;), MB_OK);\n        return 0;\n    }\n    \n    // Render target\n    ID3D11Texture2D *pBackBuffer;\n    pSwapChain-&gt;GetBuffer(0, __uuidof(ID3D11Texture2D), (void**)&amp;pBackBuffer);\n    \n    ID3D11RenderTargetView *pRTV;\n    pDevice-&gt;CreateRenderTargetView(pBackBuffer, NULL, &amp;pRTV);\n    \n    D3D11_TEXTURE2D_DESC bd;\n    pBackBuffer-&gt;GetDesc(&amp;bd);\n    \n    pBackBuffer-&gt;Release();\n    \n    // Viewport\n    D3D11_VIEWPORT vp = {0};\n    vp.Width = static_cast&lt;FLOAT&gt;(bd.Width);\n    vp.Height = static_cast&lt;FLOAT&gt;(bd.Height);\n    vp.MaxDepth = 1.0f;\n    pImmediateContext-&gt;RSSetViewports(1, &amp;vp);\n    \n    // Create the font-wrapper\n    IFW1Factory *pFW1Factory;\n    hResult = FW1CreateFactory(FW1_VERSION, &amp;pFW1Factory);\n    if(FAILED(hResult)) {\n        MessageBox(NULL, TEXT(&quot;FW1CreateFactory&quot;), TEXT(&quot;Error&quot;), MB_OK);\n        return 0;\n    }\n    \n    IFW1FontWrapper *pFontWrapper;\n    hResult = pFW1Factory-&gt;CreateFontWrapper(pDevice, L&quot;Arial&quot;, &amp;pFontWrapper);\n    if(FAILED(hResult)) {\n        MessageBox(NULL, TEXT(&quot;CreateFontWrapper&quot;), TEXT(&quot;Error&quot;), MB_OK);\n        return 0;\n    }\n    \n    pFW1Factory-&gt;Release();\n    \n    // Get DWrite factory\n    IDWriteFactory *pDWriteFactory;\n    hResult = pFontWrapper-&gt;GetDWriteFactory(&amp;pDWriteFactory);\n    \n    // Set up custom font collection\n    IDWriteFontCollectionLoader *pCollectionLoader = new CCollectionLoader(CUSTOMFONT_FILEPATH);\n    \n    hResult = pDWriteFactory-&gt;RegisterFontCollectionLoader(pCollectionLoader);\n    if(FAILED(hResult)) {\n        MessageBox(NULL, TEXT(&quot;RegisterFontCollectionLoader&quot;), TEXT(&quot;Error&quot;), MB_OK);\n        return 0;\n    }\n    \n    IDWriteFontCollection *pFontCollection;\n    hResult = pDWriteFactory-&gt;CreateCustomFontCollection(pCollectionLoader, NULL, 0, &amp;pFontCollection);\n    if(FAILED(hResult)) {\n        MessageBox(NULL, TEXT(&quot;CreateCustomFontCollection&quot;), NULL, MB_OK);\n        return 0;\n    }\n    \n    // Create the default DWrite text format for the text layout\n    IDWriteTextFormat *pTextFormat;\n    hResult = pDWriteFactory-&gt;CreateTextFormat(\n        CUSTOMFONT_NAME,\n        pFontCollection,// Use custom font collection\n        DWRITE_FONT_WEIGHT_NORMAL,\n        DWRITE_FONT_STYLE_NORMAL,\n        DWRITE_FONT_STRETCH_NORMAL,\n        32.0f,\n        L&quot;&quot;,\n        &amp;pTextFormat\n    );\n    \n    // Create a text layout for a string\n    IDWriteTextLayout *pTextLayout;\n    const WCHAR str[] = L&quot;test string 12345f!!&quot;;\n    hResult = pDWriteFactory-&gt;CreateTextLayout(\n        str,\n        sizeof(str)/sizeof(str[0]),\n        pTextFormat,\n        0.0f,\n        0.0f,\n        &amp;pTextLayout\n    );\n    pTextLayout-&gt;SetWordWrapping(DWRITE_WORD_WRAPPING_NO_WRAP);\n    \n    pFontCollection-&gt;Release();\n    pDWriteFactory-&gt;UnregisterFontCollectionLoader(pCollectionLoader);\n    pCollectionLoader-&gt;Release();\n    pDWriteFactory-&gt;Release();\n    \n    // Main loop\n    ShowWindow(hWnd, nCmdShow);\n    \n    bool loop = true;\n    while(loop) {\n        MSG msg;\n        if(PeekMessage(&amp;msg, NULL, 0, 0, PM_REMOVE) != 0) {\n            if(msg.message == WM_QUIT)\n                loop = false;\n            else {\n                TranslateMessage(&amp;msg);\n                DispatchMessage(&amp;msg);\n            }\n        }\n        else {\n            pImmediateContext-&gt;OMSetRenderTargets(1, &amp;pRTV, NULL);\n            \n            FLOAT backgroundColor[4] = {0.2f, 0.3f, 0.4f, 1.0f};\n            pImmediateContext-&gt;ClearRenderTargetView(pRTV, backgroundColor);\n            \n            FLOAT posX = 100.0f;\n            FLOAT posY = 50.0f;\n            \n            // Draw the text layout\n            pFontWrapper-&gt;DrawTextLayout(pImmediateContext, pTextLayout, posX, posY, 0xffffffff, 0);\n            \n            // Present\n            pSwapChain-&gt;Present(0, 0);\n        }\n    }\n    \n    // Release\n    pSwapChain-&gt;SetFullscreenState(FALSE, NULL);\n    \n    pImmediateContext-&gt;ClearState();\n    \n    pTextFormat-&gt;Release();\n    pTextLayout-&gt;Release();\n    \n    pFontWrapper-&gt;Release();\n    \n    pRTV-&gt;Release();\n    \n    pImmediateContext-&gt;Flush();\n    pImmediateContext-&gt;Release();\n    pDevice-&gt;Release();\n    pSwapChain-&gt;Release();\n    \n    UnregisterClass(wc.lpszClassName, hInstance);\n    \n    return 0;\n}\n\n// Window procedure\nLRESULT CALLBACK WndProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam) {\n    switch(msg) {\n        case WM_DESTROY:\n            PostQuitMessage(0);\n        return 0;\n    }\n    \n    return DefWindowProc(hWnd, msg, wParam, lParam);\n}\n</code></pre>\n\n",
    "PostedDate": "2013-05-31T17:31:45.303-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1051429",
    "ThreadId": "445629",
    "Html": "Works like a charm! Thanks for such a quick reply!<br />\n",
    "PostedDate": "2013-05-31T18:09:10.963-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  }
]